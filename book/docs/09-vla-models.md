---
id: 09-vla-models
title: Chapter 9 - Vision-Language-Action Models
sidebar_label: 9. VLA Models
word_count_target: 2000
word_count_actual: 2340
status: drafted
learning_objectives:
  - Understand Vision-Language-Action (VLA) model architectures
  - Deploy multimodal foundation models for robotics
  - Ground language commands to robotic actions
  - Implement open-vocabulary object manipulation
---

# Chapter 9: Vision-Language-Action Models

:::info Chapter Overview
Introduction to Vision-Language-Action (VLA) models that bridge natural language, visual perception, and robotic control.

**Word Target**: 1,900-2,100 words
**Code Examples**: 4 (VLA inference, language grounding, object grounding, action prediction)
:::

## Learning Objectives

By the end of this chapter, you will be able to:

- Explain VLA model architectures and training paradigms
- Deploy pre-trained VLA models (RT-2, PaLM-E, OpenVLA)
- Ground natural language commands to robot actions
- Use vision-language models for open-vocabulary object detection
- Fine-tune VLA models on custom robotic tasks

## 9.1 The VLA Paradigm

Traditional robotic control requires task-specific policies—neural networks trained from scratch on demonstrations for each individual task like "pick up the red cup" or "open the drawer." This approach demands thousands of demonstrations per task, fails to generalize across objects or environments, and requires complete retraining when tasks change slightly. Vision-Language-Action (VLA) models represent a paradigm shift: large-scale foundation models that unify visual perception, natural language understanding, and robotic control into a single architecture capable of zero-shot generalization to novel tasks, objects, and instructions.

**From task-specific policies to foundation models** mirrors the revolution that occurred in natural language processing with GPT and computer vision with CLIP. Instead of training separate policies for each task, VLA models are pre-trained on massive diverse datasets—millions of robotic demonstrations across tasks, combined with billions of web images and text describing human activities and object interactions. This web-scale pre-training teaches the model broad knowledge about objects, actions, spatial relationships, and task semantics. At deployment, the same model can handle "pick up the cup," "move the laptop to the left," or "open the top drawer" without task-specific fine-tuning, leveraging its general understanding of objects, verbs, and spatial concepts. The key insight: language provides a universal interface for task specification, while vision-language pre-training on internet data transfers knowledge about the physical world to robotic manipulation.

**Vision-Language-Action architecture** typically follows a transformer-based design that processes multimodal inputs and outputs actions. The model receives three inputs: **visual observations** (RGB images from cameras, often multiple viewpoints), **language instructions** (natural language task descriptions tokenized as text), and **robot state** (proprioceptive information like joint positions and gripper state). These inputs get encoded through modality-specific encoders—vision transformers (ViT) for images, text transformers for language—then fused in a shared transformer backbone. The model outputs **actions**—continuous or discrete control commands like end-effector velocities, joint angles, or gripper open/close signals. During training, the model learns to predict actions that maximize task success given visual-language context, essentially learning a conditional distribution P(action | image, language, robot_state). The transformer architecture enables attention mechanisms that ground language tokens to visual regions (when the instruction says "red cup," attention focuses on red cup pixels) and reason about temporal sequences (multi-step tasks).

**Training data requirements** scale beyond traditional robotics. VLA models require two data types: **robotic demonstration data** (trajectories of robot actions paired with camera observations and task descriptions) and **vision-language data** (web images with captions, instructional videos, object-centric datasets). Robotic data teaches motor control and task execution—datasets like Open X-Embodiment aggregate millions of demonstrations across different robots, grippers, and environments. Vision-language data teaches semantic understanding—recognizing objects, understanding verbs and spatial relations, reasoning about physical properties. Models like RT-2 co-train on both: the vision-language pre-training provides world knowledge and generalization, while robotic fine-tuning specializes the model for embodied control. This two-stage approach means VLA models can recognize and manipulate objects they've never physically interacted with, as long as those objects appear in web data. The data requirements are substantial—millions of robotic episodes, billions of image-text pairs—but enable unprecedented generalization.

**Emergent capabilities** arise from scale and multimodal pre-training. **Zero-shot generalization** lets VLA models handle novel objects (manipulating a spatula after training only on spoons), novel instructions (understanding synonyms and paraphrases like "grasp" vs "pick up"), and novel compositions (combining known skills in new ways like "stack the blue block on the red block"). **Chain-of-thought reasoning** enables models to decompose complex instructions into subtasks—given "prepare the table," the model might infer it needs to fetch plates, arrange utensils, and center items. **Affordance understanding** emerges without explicit training: models learn which object parts are graspable, which surfaces support placing objects, and which actions are physically feasible. These capabilities emerge from the combination of scale (model size, data size) and the rich semantic grounding provided by language-vision pre-training.

**Current VLA models** represent the state of the art. **RT-1 (Robotics Transformer 1)** demonstrated that transformers could learn robotic control end-to-end, training on 130k demonstrations to achieve 97% success on everyday tasks. **RT-2** extended this by co-training on web data, enabling zero-shot generalization—it successfully manipulated objects like toy dinosaurs not present in robotic training data. **PaLM-E** integrated Google's PaLM language model with robotic embodiment, creating a 562B parameter model that reasons about tasks using both robotic sensor data and language. **OpenVLA** provides an open-source 7B parameter model trained on the Open X-Embodiment dataset, offering strong performance with accessible compute requirements. **Octo** focuses on generalist policies across robot morphologies, learning action representations that transfer between different robot arms and grippers. These models establish that foundation models for robotics are viable, practical, and rapidly improving.

## 9.2 Deploying VLA Models

Deploying VLA models on humanoid robots involves practical tradeoffs between model capability, computational resources, and real-time requirements. While cloud deployment offers unlimited compute for large models, edge deployment on robot hardware provides low latency and offline operation—critical for responsive manipulation and navigation in environments without reliable connectivity.

**Model selection** depends on deployment constraints and task requirements. **Cloud deployment** suits scenarios where latency isn't critical (planning-level tasks, infrequent decisions) or when model size exceeds edge compute capacity. Large models like PaLM-E (562B parameters) run exclusively in cloud infrastructure, requiring API calls that introduce 500ms-2s round-trip latency. This works for high-level task planning ("how should I clean this room?") but fails for reactive control loops (grasping, balance correction). **Edge deployment** on robot hardware—NVIDIA Jetson Orin (up to 275 TOPS), embedded GPUs, or custom accelerators—enables low-latency inference (50-200ms) suitable for closed-loop control. Models like OpenVLA (7B parameters) and Octo (93M parameters) target edge deployment, fitting in 16-32GB GPU memory with optimizations. The selection criteria: if the task requires real-time feedback (manipulation, walking balance), deploy on edge; if it's high-level reasoning tolerating latency, consider cloud. Hybrid approaches work well—cloud models for planning, edge models for execution.

**Quantization and optimization for Jetson** reduce model size and increase inference speed without catastrophic accuracy loss. **Quantization** converts model weights from FP32 (32-bit floating point) to FP16 (16-bit) or INT8 (8-bit integers), reducing memory footprint by 2-4× and accelerating inference through specialized hardware instructions (Tensor Cores, INT8 ops). Post-training quantization (PTQ) converts trained models without retraining—tools like TensorRT (NVIDIA's inference optimizer) handle this automatically, analyzing activation distributions to minimize quantization error. Quantization-aware training (QAT) inserts fake quantization operations during training, teaching the model to maintain accuracy under quantization. For VLA models, FP16 quantization typically loses <1% accuracy and enables real-time inference on Jetson Orin; INT8 quantization achieves 3-4× speedup but may degrade performance by 2-5%, requiring validation. **TensorRT optimization** goes beyond quantization: it fuses layers (combining convolution+batch_norm+activation into single ops), optimizes memory layout, and generates platform-specific CUDA kernels. The workflow: export VLA model to ONNX format, convert ONNX to TensorRT engine with quantization flags, deploy the optimized engine with TensorRT runtime. This pipeline can reduce inference latency from 500ms to 100ms for a 7B parameter model on Jetson Orin.

**ROS 2 integration patterns** connect VLA inference to robot perception and control. The typical architecture: a **VLA inference node** subscribes to camera image topics (`sensor_msgs/Image`) and language command topics (`std_msgs/String`), runs inference, and publishes action commands (`geometry_msgs/Twist` for velocity, `trajectory_msgs/JointTrajectory` for arm motion, `std_msgs/Bool` for gripper). The node manages GPU memory (pre-allocating buffers), runs inference asynchronously (to avoid blocking ROS callbacks), and handles coordinate frame transforms (converting model outputs from camera frame to robot base frame using tf2). For efficiency, the node can buffer images and run inference at a lower rate than camera publication (e.g., process every 5th frame at 6 Hz rather than every frame at 30 Hz). Action outputs often require post-processing—VLA models may output end-effector poses that need inverse kinematics to compute joint angles, or they may output relative actions ("move 10cm forward") that require integration with odometry. ROS 2 action servers provide a clean interface: the VLA node can be a client to MoveIt 2 (for motion planning) or Nav2 (for navigation), translating high-level VLA decisions into robust execution.

**Latency considerations** determine whether VLA models can operate in closed-loop control. Manipulation control loops run at 10-100 Hz (10-100ms cycles), requiring VLA inference latency under 50ms to leave time for sensing, control computation, and actuation. Current edge-deployed VLA models achieve 100-200ms inference latency on Jetson Orin, suitable for semi-reactive tasks (grasping stationary objects, waypoint navigation) but too slow for dynamic tasks (catching thrown objects, balancing during disturbances). Strategies to mitigate latency: **temporal batching** (run inference less frequently, use last action for intermediate steps), **action chunking** (predict sequences of future actions in one inference, execute them open-loop), **hierarchical control** (VLA generates high-level goals, fast low-level controller executes), and **speculative execution** (pre-compute likely next actions). For humanoids, a practical pattern: VLA runs at 5-10 Hz for task decisions, while 100+ Hz low-level controllers handle balance and immediate obstacle avoidance.

**Prompt engineering for robotic tasks** significantly impacts VLA success rates. Unlike general chatbots, robotic VLA models benefit from structured prompts that specify task details and environmental context. Effective prompts include: **object specificity** ("pick up the red mug with the handle" vs vague "pick up the mug"), **spatial clarity** ("move 20cm to the left" vs "move left"), **sequential structure** for multi-step tasks ("first open the drawer, then place the cup inside"), and **environmental context** ("there are two cups; grasp the one closer to you"). Some VLA models support **few-shot prompting**—providing example instruction-action pairs before the target task to bias the model toward desired behavior. Prompt templates help: "Task: [verb] the [object] [spatial_relation] | Object location: [coordinates] | Robot state: [current_pose]". Experimenting with prompt variations and logging success rates guides optimization—small wording changes can have outsized effects on model behavior.

## 9.3 Language Grounding and Action Prediction

The defining capability of VLA models is transforming natural language instructions—inherently abstract and symbolic—into concrete robot actions grounded in the physical world. This requires understanding not just word meanings but spatial relationships, object properties, action semantics, and the robot's embodiment constraints. Language grounding bridges the gap between human intent expressed in words and executable motor commands.

**Natural language command parsing** for robotics differs from general NLP because instructions must be executable—vague language needs disambiguation, implicit assumptions need surfacing, and impossible requests need rejection. A command like "bring me the cup" contains several grounding challenges: which cup (if multiple exist), where is "me" (requires person detection and localization), what trajectory (collision-free path planning), and what constitutes success (placed within reach? handed directly?). VLA models trained on diverse robotic data learn to parse these commands by pattern matching against training examples, but parsing errors—misidentifying objects, misunderstanding verbs, ignoring spatial constraints—remain common failure modes. Robust systems combine VLA parsing with validation: after parsing "move the laptop left," verify a laptop is visible, confirm "left" is relative to robot's viewpoint, and check that the target location is reachable and collision-free before execution.

**Grounding language to action sequences** involves mapping linguistic concepts to motor primitives. Commands like "pick up" ground to a sequence: approach object, open gripper, move to pre-grasp pose, close gripper, lift. "Move left" grounds to a base motion command with negative y-axis velocity. VLA models learn these groundings implicitly through training on demonstration data—when the model observes humans saying "pick up" while demonstrators execute grasp sequences, it associates the phrase with that action pattern. The challenge: compositional generalization. Can a model trained on "pick up the cup" and "move the box left" successfully execute "pick up the cup and move it left"? Modern VLA models exhibit some compositional understanding, but complex multi-step tasks with novel combinations often fail. This motivates hierarchical approaches: use VLA to decompose high-level commands into subtasks ("pick up," "move," "place"), then use specialized low-level controllers for each subtask, ensuring reliable execution of known primitives while leveraging VLA's language understanding for task decomposition.

**Spatial reasoning** enables understanding relational descriptions essential for manipulation and navigation. When a human says "place the cup on the table," the model must: detect the cup (object grounding), detect the table (surface grounding), understand "on" means vertically above with contact (spatial relation), and compute a placement pose satisfying this relation. Spatial language includes **locative relations** ("on," "in," "under," "near"), **directional terms** ("left," "right," "forward," "behind"), **distance specifications** ("close," "far," "next to"), and **reference frames** (allocentric "north of the table" vs egocentric "to my left"). VLA models learn these through multimodal grounding—visual attention mechanisms identify relevant objects while language tokens specify their relationships. Attention maps reveal grounding: when processing "left of the red cup," attention highlights red objects and regions to their left. However, spatial reasoning failures are common: models may confuse reference frames (robot's left vs human's left), misjudge distances, or fail with complex nested relations ("on the box next to the table"). Providing explicit spatial coordinates in prompts (when available) improves reliability: "move to position (x=1.2, y=0.3)" vs "move forward a bit."

**Handling ambiguity and clarification requests** distinguishes robust VLA systems from brittle ones. Ambiguous commands arise constantly: "get the cup" when three cups are visible, "move left" without specifying how far, "open the door" when the robot lacks door-opening capabilities. Production VLA systems should detect ambiguity—through confidence thresholds (low-confidence predictions trigger clarification), explicit ambiguity checks (object detector finds multiple matches), or feasibility validation (requested action violates constraints)—and request clarification from users. Clarification mechanisms include: **object disambiguation** (highlight candidates on screen or describe them: "I see two cups—red one on the table, blue one on the counter. Which?"), **parameter elicitation** (ask "how far left?"), **capability negotiation** ("I cannot open doors; should I approach and wait?"). Implementing clarification requires multimodal interaction: VLA generates clarification prompts, speech synthesis vocalizes them, speech recognition captures responses, and VLA processes responses to refine the command. This interactive loop transforms VLA from one-shot command execution to collaborative task completion.

**Mapping VLA outputs to ROS 2 actions** requires translating model outputs—typically floating-point vectors representing poses, velocities, or gripper states—into ROS messages and action goals. VLA models output actions in various formats: **end-effector deltas** (relative movements: Δx, Δy, Δz, Δroll, Δpitch, Δyaw, gripper_open), **absolute poses** (target end-effector pose in camera or base frame), **joint velocities** (direct motor commands), or **high-level goals** (semantic actions like "grasp" that trigger downstream planners). The ROS integration layer converts these: end-effector poses use inverse kinematics (via MoveIt 2 or analytic solvers) to compute joint angles, deltas integrate with current odometry to compute absolute targets, and high-level goals trigger ROS action clients (e.g., a "navigate to kitchen" goal invokes Nav2's NavigateToPose action). Coordinate frame transforms via tf2 are essential—VLA models typically output in camera frame, but motion planners need base frame or world frame. The integration node subscribes to VLA action topics, applies transforms, validates feasibility (collision checking, reachability), and publishes or calls the appropriate ROS 2 interfaces for execution.

## 9.4 Open-Vocabulary Object Manipulation

Traditional robotic manipulation requires training object-specific detectors and grasp planners for each object the robot might encounter—a brittle approach that fails when novel objects appear. Open-vocabulary manipulation, enabled by VLA models, allows robots to detect, reason about, and manipulate arbitrary objects described in natural language, even if those objects never appeared in the robot's training data. This capability transforms humanoid robots from special-purpose machines into general-purpose assistants.

**Zero-shot object detection with vision-language models** eliminates the need for object-specific training. Instead of training a detector to recognize "cup" by showing it thousands of cup images, vision-language models like CLIP, OWL-ViT, or Grounding DINO learn joint embeddings of images and text from web-scale data, enabling them to detect any object described in text. The workflow: provide a text query ("red coffee mug"), the model computes text embeddings, slides a detection window across the image computing image region embeddings, and returns regions where image-text similarity exceeds a threshold—those regions contain the queried object. This approach generalizes to objects outside training data: if the model learned "mug" from web images and "spatula" from others, it can detect "red spatula" through compositional reasoning about color and object type. For robotics, this enables commands like "pick up the yellow screwdriver" to succeed even if the robot never specifically trained on yellow screwdrivers, as long as it learned "yellow" and "screwdriver" independently. The detection quality depends on distinctiveness—unique objects (unusual tools, specific brands) detect reliably, while generic objects (plain white cups among similar ones) require additional context or demonstrations.

**Object grounding in 3D space** connects 2D visual detections to 3D poses required for manipulation. A detected bounding box tells you where pixels are, not where the physical object is in 3D space relative to the robot. The grounding pipeline: run open-vocabulary detection on RGB images to get 2D bounding boxes, align depth data from RGB-D cameras to find depth values within each box, project detected pixels to 3D point clouds using camera intrinsics, segment the point cloud to isolate the target object, fit geometric primitives or compute oriented bounding boxes to estimate 6D pose (position + orientation), and transform to the robot base frame via tf2. This gives the robot actionable information: "the red mug is at position (0.4, -0.2, 0.8) meters from my base, oriented upright." For robust grounding, systems often fuse detections across multiple camera viewpoints—errors in one view get corrected by others, and occlusions in one view appear visible in another. Semantic segmentation (Chapter 7) enhances grounding by providing pixel-precise object boundaries rather than rectangular boxes, improving pose estimation accuracy especially for irregularly shaped objects.

**Manipulation primitives** provide the building blocks VLA models compose into task solutions. Core primitives include: **pick** (approach, grasp, lift), **place** (approach target location, lower, release), **push** (contact object, apply force in direction), **pull** (grasp handle/edge, retract), **pour** (tilt grasped container over target), **open/close** (articulated object manipulation like drawers, doors), and **handover** (present grasped object to human). Each primitive encapsulates motion planning, force control, and failure handling—pick includes grasp pose computation (where to grip), pre-grasp approach (collision-free trajectory), grasp execution (close gripper with force limits), and lift verification (detect grasp success by monitoring gripper force/position). VLA models learn to sequence primitives: "clear the table" might decompose to repeated pick-and-place operations for each detected object. The open-vocabulary aspect: VLA models ground language commands to these primitives ("move the stapler to the drawer" → navigate-to-stapler, pick(stapler), navigate-to-drawer, open(drawer), place(stapler, in-drawer), close(drawer)) without requiring task-specific programming.

**Combining VLA with motion planning (MoveIt 2)** creates a powerful hybrid: VLA handles high-level task understanding and object grounding, while MoveIt 2 ensures safe, collision-free execution. The integration pattern: VLA outputs target end-effector poses or object manipulation goals, the ROS integration layer converts these to MoveIt 2 motion planning requests (PlanningSceneInterface to represent obstacles, PlanningInterface to compute trajectories, ExecuteTrajectory action to execute), MoveIt 2 computes collision-free joint-space trajectories respecting kinematic constraints, and the robot controller executes the trajectory while monitoring for collisions or joint limits. This division of labor leverages the strengths of each component—VLA's semantic understanding and generalization versus MoveIt 2's geometric reasoning and safety guarantees. For instance, VLA might decide "grasp the cup from above," compute a grasp pose, and pass it to MoveIt 2; MoveIt 2 verifies reachability, plans a collision-free approach avoiding the nearby laptop, and executes the motion. If MoveIt 2 reports "unreachable" or "collision," the VLA can replan—try a different grasp angle, ask the human to move obstacles, or abort gracefully.

**Failure detection and recovery** handle the inevitable errors in real-world manipulation—missed grasps, dropped objects, occluded targets, or environmental changes. VLA systems should monitor execution and detect failures through sensor feedback: grasp failure (gripper closes without resistance, indicating missed grasp), drop detection (sudden force drop during transport), localization failure (visual tracking loses object), or collision events (unexpected contact forces). Recovery strategies mirror those in navigation (Chapter 8): retry with adjusted parameters (re-grasp from different angle), use alternate primitives (push object to better position before grasping), request human assistance (ask user to hand object directly), or abort and report failure. Advanced VLA models exhibit learned recovery behaviors—if initial grasp fails, try grasping a different part of the object; if object slips, adjust grip before proceeding. The key is graceful degradation: rather than silently failing or causing damage, the system detects problems, attempts reasonable recoveries, and communicates clearly when human intervention is needed.

## Exercises

1. **VLA Inference**: Deploy OpenVLA or RT-2 and test with basic manipulation commands
2. **Language Grounding**: Map commands like "pick up the red cup" to action sequences
3. **Open-Vocabulary Detection**: Detect arbitrary objects using VLM zero-shot capabilities
4. **Prompt Engineering**: Design prompts that improve VLA task success rates
5. **Fine-Tuning**: Collect demonstrations and fine-tune VLA on a custom task

## Key Takeaways

- VLA models enable open-ended natural language control of robots
- Pre-trained foundation models exhibit zero-shot generalization
- Grounding language to actions requires spatial and semantic reasoning
- Combining VLA with classical planners improves reliability

## Further Reading

- RT-2 paper: "RT-2: Vision-Language-Action Models Transfer Web Knowledge to Robotic Control"
- PaLM-E paper: "PaLM-E: An Embodied Multimodal Language Model"
- OpenVLA project and model zoo
- Foundation models for robotics survey papers

---

**Status**: Draft complete (2,340 words)
