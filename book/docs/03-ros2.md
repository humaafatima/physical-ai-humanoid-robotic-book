---
id: 03-ros2
title: Chapter 3 - ROS 2 – The Robotic Nervous System
sidebar_label: 3. ROS 2
word_count_target: 1600
word_count_actual: 1670
status: drafted
learning_objectives:
  - Understand ROS 2 architecture and DDS middleware
  - Create publishers and subscribers using rclpy
  - Implement ROS 2 services and actions
  - Launch multi-node systems with launch files
---

# Chapter 3: ROS 2 – The Robotic Nervous System

:::info Chapter Overview
Introduction to ROS 2 (Robot Operating System 2), the middleware framework that enables distributed robotic control.

**Word Target**: 1,500-1,700 words
**Code Examples**: 5 (hello world, pub/sub, services, actions, parameters)
:::

## Learning Objectives

By the end of this chapter, you will be able to:

- Explain ROS 2 architecture and its advantages over ROS 1
- Write ROS 2 nodes using Python (rclpy)
- Implement inter-node communication via topics, services, and actions
- Configure and launch multi-node robotic systems
- Debug ROS 2 systems using command-line tools

## 3.1 ROS 2 Architecture and DDS

ROS 2 (Robot Operating System 2) represents a complete architectural redesign of its predecessor, addressing fundamental limitations that emerged as robotics moved from academic labs to commercial deployment. Unlike ROS 1's centralized master-based architecture, ROS 2 adopts a peer-to-peer communication model built on the Data Distribution Service (DDS) middleware standard. This shift eliminates single points of failure, enables true distributed systems, and provides enterprise-grade features like real-time performance, security, and cross-platform compatibility that modern robotic applications demand (International Journal of Intelligent Robotics and Applications, 2024).

At the heart of ROS 2's architecture lies DDS—a proven industrial middleware standard used in mission-critical systems from aerospace to financial trading. DDS handles node discovery, message serialization, and network transport transparently, allowing ROS 2 nodes to find each other automatically across networks without centralized coordination. This peer-to-peer model means that any node can communicate directly with any other node, enabling resilient systems where individual component failures don't cascade into system-wide breakdowns. For humanoid robotics applications with dozens of sensors, actuators, and control nodes, this architecture provides the reliability needed for safe operation in human environments.

ROS 2's modularity extends beyond communication patterns to support diverse deployment scenarios. The framework provides both C++ and Python APIs (rclcpp and rclpy respectively), supports real-time operating systems through careful memory management and deterministic execution, and runs on platforms from embedded microcontrollers to cloud servers. Recent surveys of the ROS 2 ecosystem demonstrate strong adoption driven by these capabilities, with users particularly valuing the improved real-time performance and security features compared to ROS 1 (Preprints.org, 2024).

A key innovation in ROS 2 is Quality of Service (QoS) policies that allow fine-grained control over communication behavior. Different robotic data streams have different requirements: sensor data might tolerate occasional packet loss but needs low latency (best-effort, volatile QoS), while command messages require guaranteed delivery (reliable, transient-local QoS). ROS 2's QoS system allows developers to specify reliability, durability, deadline, and liveliness constraints per topic, ensuring each communication channel meets its specific needs. For humanoid robots, this means critical safety commands can use reliable delivery while high-frequency sensor streams can prioritize low latency, optimizing both safety and performance.

## 3.2 Topics and Messages

Topics form the backbone of ROS 2 communication, implementing the publisher-subscriber pattern for asynchronous, many-to-many data exchange. In this model, nodes publish messages to named topics without knowing who (if anyone) is listening, while subscriber nodes receive messages from topics they're interested in without knowing the source. This loose coupling enables modular system design where components can be added, removed, or replaced without modifying existing nodes—a critical feature for the iterative development of complex humanoid systems.

A ROS 2 topic is simply a named bus for messages of a specific type. For instance, `/camera/image_raw` might carry `sensor_msgs/Image` messages from a camera, while `/cmd_vel` carries `geometry_msgs/Twist` messages commanding robot velocity. ROS 2 provides extensive standard message types organized into packages: `std_msgs` for primitives (int, float, string), `geometry_msgs` for spatial data (poses, transforms, velocities), `sensor_msgs` for sensor data (images, point clouds, IMU readings), and domain-specific packages for navigation, manipulation, and perception. This standardization enables interoperability—a path planning node expecting `geometry_msgs/PoseStamped` messages can work with any localization system that publishes this standard message type.

Creating publishers and subscribers in Python using rclpy follows a straightforward pattern. Publishers are instantiated with a message type and topic name, then call `publish()` to send messages. Subscribers register a callback function that executes whenever a new message arrives. This asynchronous callback model means subscriber nodes don't block waiting for messages—they process data as it arrives while continuing other work. For humanoid robots with dozens of concurrent sensor streams and control loops, this asynchronous architecture enables efficient parallel processing without complex threading logic.

Topic discovery happens automatically through DDS: when a publisher announces a topic, interested subscribers connect transparently across the network. ROS 2's command-line tools provide powerful introspection capabilities. `ros2 topic list` shows all active topics, `ros2 topic echo /topic_name` displays messages in real-time, `ros2 topic hz /topic_name` measures publication rates, and `ros2 topic info /topic_name --verbose` reveals publishers, subscribers, and QoS settings. These tools are indispensable for debugging—when your humanoid robot isn't responding to commands, checking if control messages are actually being published at the expected rate is the first diagnostic step. Understanding topics deeply enables you to architect systems where perception, planning, and control components communicate efficiently through well-defined message interfaces.

## 3.3 Services and Actions

While topics excel at continuous data streams, many robotic interactions follow request-response patterns where a node needs to ask another node to perform a specific task and wait for the result. ROS 2 provides two mechanisms for this: services for quick synchronous operations and actions for long-running asynchronous tasks with progress feedback. Understanding when to use each pattern is crucial for building responsive humanoid robot systems.

**Services** implement synchronous remote procedure calls. A service client sends a request message and blocks until receiving a response from the service server. This pattern suits operations that complete quickly—querying the current robot state, computing inverse kinematics for a given pose, or toggling a sensor mode. Services are defined by `.srv` files specifying request and response message structures. For example, a `ComputeIK.srv` might request a target pose and return joint angles. The key limitation is that service calls block: if your inverse kinematics computation takes 5 seconds, the client waits 5 seconds. For operations that might take significant time, services become problematic—blocking prevents clients from processing other work and provides no visibility into progress.

**Actions** solve this limitation by implementing asynchronous goal-oriented tasks with feedback. An action client sends a goal to an action server and immediately returns, allowing the client to continue other work. The server processes the goal in the background, periodically sending feedback messages about progress, and eventually returns a result. Crucially, clients can cancel goals mid-execution if circumstances change. Actions are defined by `.action` files with three message types: goal (what to do), result (final outcome), and feedback (progress updates). Consider a "WalkToLocation" action for a humanoid robot: the goal specifies target coordinates, feedback reports current position and estimated time remaining, and the result indicates success or failure with final position and obstacles encountered.

The distinction between services and actions maps to task duration and complexity. Services suit sub-second operations where blocking is acceptable: "What's the current battery level?" (service returning a float). Actions suit multi-second or multi-minute operations requiring monitoring: "Navigate to the kitchen" (action with feedback on navigation progress, ability to cancel if user changes plans). For humanoid manipulation—like "Pick up the cup"—actions are essential. The task involves multiple phases (approach, grasp planning, execution, retreat), may take 10-30 seconds, could fail at any phase requiring different error handling, and benefits from feedback ("approaching object", "computing grasp", "executing grasp"). This action-based architecture enables responsive behaviors where higher-level controllers can monitor and react to lower-level task execution, a pattern we'll use extensively for autonomous humanoid behaviors in later chapters. The ROS 2 framework's integration with heterogeneous hardware environments makes services and actions particularly powerful for coordinating complex multi-component robotic systems (PMC - Electronics Journal, 2024).

## 3.4 Parameters and Launch Files

Robotic systems require extensive configuration: sensor calibration values, control gains, file paths, algorithm thresholds, and behavioral settings. Hardcoding these values forces recompilation for every change, making experimentation painful. ROS 2's parameter system provides runtime configurability, allowing nodes to declare parameters with default values and update them dynamically without code changes. For humanoid robots with dozens of tunable parameters across perception, control, and planning subsystems, this flexibility accelerates development significantly.

Parameters in ROS 2 are strongly typed (bool, int, double, string, or arrays) and scoped to specific nodes. A node declares parameters during initialization, specifying names, types, default values, and optionally validation constraints. Parameters can be set via command-line arguments when launching nodes (`--ros-args -p max_speed:=2.0`), loaded from YAML configuration files, or modified at runtime using `ros2 param set /node_name parameter_name value`. Nodes can register callbacks that execute when parameters change, enabling dynamic reconfiguration—adjusting a PID controller's gains while the robot operates, for instance. This live-tuning capability is invaluable during development: you can observe your humanoid's walking behavior, adjust control parameters in real-time, and immediately see the effects without restarting the entire system.

**Launch files** orchestrate complex multi-node systems, specifying which nodes to start, how to configure them, and how to connect them. ROS 2 uses Python-based launch files (unlike ROS 1's XML format), providing full programmatic control through conditionals, loops, and parameter calculations. A typical humanoid robot launch file might start sensor drivers, perception pipelines, motion planning nodes, and control interfaces—potentially 20+ nodes—with appropriate parameters, namespaces, and remappings. Launch files can include other launch files, enabling modular composition: a base launch file for the robot platform, separate launch files for navigation, manipulation, and perception capabilities that can be mixed and matched.

Launch files support **composable nodes**—loading multiple nodes into a single process to eliminate inter-process communication overhead. For high-frequency control loops or tightly coupled perception-action pairs, composable nodes reduce latency significantly. **Namespaces** enable running multiple robots or component instances: launching two instances of a perception pipeline under `/robot1` and `/robot2` namespaces keeps their topics separate (`/robot1/camera/image` vs `/robot2/camera/image`). This becomes essential for multi-robot scenarios or when testing different parameter configurations simultaneously.

The combination of parameters and launch files creates a powerful workflow: develop and test individual nodes, compose them into systems via launch files, tune behavior through parameters, and package proven configurations for deployment. The ROS 2 community's emphasis on increasing robot autonomy through these modular frameworks demonstrates their importance for building complex, configurable robotic systems (MDPI Applied Sciences, 2023). For this course, you'll use launch files extensively to orchestrate Isaac Sim environments, sensor pipelines, navigation stacks, and manipulation systems—gaining hands-on experience with the standard approach for managing real-world robotic complexity.

## Code Examples

### Example 1: Hello ROS 2 Node
**Directory**: `code-examples/chapter-03-ros2/hello_ros2/`
**Learning Goal**: Create and run a basic ROS 2 node
**Time**: 5 minutes

### Example 2: Publisher and Subscriber
**Directory**: `code-examples/chapter-03-ros2/pub_sub/`
**Learning Goal**: Implement asynchronous topic communication
**Time**: 15 minutes

### Example 3: Service Client/Server
**Directory**: `code-examples/chapter-03-ros2/service_example/`
**Learning Goal**: Implement synchronous request-response pattern
**Time**: 15 minutes

### Example 4: Action Client/Server
**Directory**: `code-examples/chapter-03-ros2/action_example/`
**Learning Goal**: Implement long-running tasks with feedback
**Time**: 20 minutes

### Example 5: Parameters and Launch
**Directory**: `code-examples/chapter-03-ros2/parameters/`
**Learning Goal**: Configure nodes via parameters and launch multiple nodes
**Time**: 15 minutes

## Exercises

1. **Basic Node**: Create a ROS 2 node that prints "Hello from ROS 2!" every second.

2. **Temperature Publisher**: Create a publisher that publishes simulated temperature readings (random float between 20-30°C) to `/temperature` topic every 0.5 seconds.

3. **Echo Subscriber**: Create a subscriber that listens to `/temperature` and prints "Current temperature: X°C" for each message.

4. **Addition Service**: Implement a service that takes two integers and returns their sum. Create both server and client nodes.

5. **Fibonacci Action**: Implement an action server that computes Fibonacci sequence up to n terms, providing feedback for each computed term.

6. **Multi-Node Launch**: Create a launch file that starts a temperature publisher, an echo subscriber, and sets a parameter for publication rate.

7. **Namespace Practice**: Modify your nodes to work with namespaces (e.g., `/robot1/temperature`, `/robot2/temperature`).

8. **QoS Policies**: Experiment with different QoS settings (reliable vs. best-effort, volatile vs. transient-local) and observe behavior.

9. **Topic Remapping**: Use launch file remapping to connect nodes with different topic names.

10. **ROS 2 CLI Tools**: Use `ros2 topic list`, `ros2 node info`, `ros2 interface show` to inspect a running system.

## Troubleshooting

**Problem**: `ImportError: No module named 'rclpy'`
**Solution**: Ensure you're running inside the Docker container. Run `docker-compose up` from the example directory.

**Problem**: Nodes can't find each other
**Solution**: Check that all nodes are using the same ROS_DOMAIN_ID (default: 0). Set explicitly: `export ROS_DOMAIN_ID=42`

**Problem**: Publisher/subscriber not communicating
**Solution**: Verify QoS compatibility using `ros2 topic info /topic_name --verbose`

---

**Next Chapter**: [Chapter 4: URDF & Robot Modeling →](./04-urdf.md)
